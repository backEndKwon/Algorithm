/* 
p.273
17-8 서커스 타워
위에 올라타는 사람은 아래 있는 사람보다 가벼우면서 키도 작아야함
*/
/* 
[생각해보기]
위에 올라타는 사람이 가볍지만 키는 크다면?

위에 올라타기 위해선 이전사람보다 키도작고 가벼워야 한다. => 하나의 함수로

맨 밑에 둘 사람은 어떻게 고를 것인가?
우선은 몸무게가 제일 무거운 사람으로
// 책에서는 이상하게도 
*/
const people = [
  [65, 100],
  [70, 150],
  [56, 90],
  [75, 190],
  [60, 95],
  [68, 110],
];

// 키와 몸무게를 기준으로 오름차순 정렬
people.sort((a, b) => {
  if (a[1] === b[1]) {
    return a[0] - b[0];
  } else {
    return a[1] - b[1];
  }
});

//중복계산을 줄이기위해 dp사용
let dp = Array(people.length).fill(1);//공간 복잡도 O(N)

//시간 복잡도 O(N^2)
for (let i = 1; i < people.length; i++) {
  for (let j = 0; j < i; j++) {//for문은 현재 자기자신(i)과 이전 값(j<i)와 계속 비교하면서 로직 진행
    //만약 다음 people(people[i][1])의 키가 이전 people의(people[j][1])들보다 크다)
    if (people[i][1] >= people[j][1]) {
      dp[i] = Math.max(dp[i], dp[j] + 1); //사람i가 사람 j위에 올라가수 있다면? 사람j기준으로 탑의 높이에 1을 더한 값과, 사람 i를 기준으로 하는 탑의 높이중 더 큰 값으로 업데이트
     }
     // i=2(즉, [65, 100]인 사람), j=1(즉, [60, 95]인 사람)인 경우를 확인
     // 이 경우, 사람 i가 사람 j 위에 올라갈 수 있으므로, 
     //dp[2] = Math.max(dp[2], dp[1] + 1); 코드를 통해 dp[2]의 값을 2로 업데이트
     console.log(dp)
  }
}
let maxLength = Math.max(...dp);
console.log("👉 ~ maxLength:", maxLength)
